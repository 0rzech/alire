DESIGN PRINCIPLES:
    Minimal user hassle => Provide a library/app name to build => Alire must contain a map [Name -> Repo]
    Don't force pollution of maintainer code => no extra information/tags for alire
        => Submissions to alire must be merge requests of the relevant information
    Also, alire must be able to understand origins that are uncatalogued (giving the URL/PATH) for developers working on their own libraries, prior to official incorporation

Search path of project-alire.ads file, in order:
    In current folder
    In any immediate subfolder

BOOTSTRAP
    $ curl -sSf https://static.rust-lang.org/rustup.sh | sh

COMMANDS for 1.0

Legend:
* implemented

* build:
    upgrade:
    compile:

clean:
    gprclean with alire agg project

compile: 
    Launch gprbuild as-is

execute:
    look for executable named as project
        If one: report path and launch
        If none/more: error

generate:
    create gpr aggregate project for building, using info in the project-alire.ads file
    named project_alirebuild.gpr

get:
    clone repo of the given project
    --build to then build it

init: (new is reserved word in Ada, better avoid)
    Prepares a new project with given name in name folder
    --bin or --lib mandatory
    generates skeleton files:
        project.gpr
        project-alire.ads
    generate:

lock:
    overwrite project-alire.ads with current exact dependencies

run:
    compile:
    execute:

search: 
    list libraries with a substring in their name
    -v: show versions

update:
    Gets latest alire index & alr app (--full --alr --index)
    upgrade:

upgrade:
    Recompute dependencies from project-alire.ads
    fetch: every newest dependency
    generate:
